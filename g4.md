This is the final, comprehensive "source of truth" for your platform. It combines a hardened Turborepo + pnpm structure with Vite Module Federation, environment-driven routing, and a deployment strategy that works for both Vercel and AWS (EKS/Helm).
ðŸ— High-Level Architecture
The platform follows a Host-Remote architecture using "Module Federation."
 * The Shell (Host): Acts as the entry point. It handles global navigation, authentication, and lazy-loads the remotes based on the URL path.
 * MFE1 & MFE2 (Remotes): Independent React applications. They "expose" their entry components. When the Shell is built, it doesn't contain MFE code; it fetches it at runtime.
 * Shared UI (@repo/ui): A local workspace package. This ensures the Shell and MFEs use the same design system without duplicating code in the final bundles.
 * The Routing Strategy: We use Path-Based Routing.
   * / -> Serves the Shell.
   * /mfe1/* -> Proxied/Routed to MFE1.
   * /mfe2/* -> Proxied/Routed to MFE2.
ðŸ›  The Deployment Strategy
Phase 1: Vercel (POC)
We use a single vercel.json in the monorepo root (or linked to the Shell project). The Rewrites engine acts as a reverse proxy. It ensures that if a user requests a file at /mfe1/assets/..., Vercel knows to look in the apps/mfe-apps/mfe1/dist directory.
Phase 2: AWS (Production)
We transition to Docker + Nginx.
 * Bamboo: Runs the build and packages the entire monorepo into a Docker image.
 * JFrog: Stores the versioned Docker image.
 * Nginx: Inside the container, Nginx is configured to serve the Shell at the root and the MFEs at their specific subfolders, mirroring the Vercel behavior exactly.
 * Helm: Deploys the container to EKS and sets up the Ingress/ALB rules.
ðŸš€ The Master Scaffold Script
Save the following as setup-platform.sh, then run chmod +x setup-platform.sh && ./setup-platform.sh.
#!/bin/bash
set -e

APP_NAME=mfe-platform
mkdir $APP_NAME && cd $APP_NAME

# 1. Root Workspace & Turbo Configuration
pnpm init -y
cat <<EOF > package.json
{
  "name": "$APP_NAME",
  "private": true,
  "scripts": {
    "dev": "turbo dev",
    "build": "turbo build",
    "preview": "turbo preview"
  },
  "devDependencies": {
    "turbo": "^1.13.0",
    "typescript": "^5.2.2"
  }
}
EOF

cat <<EOF > pnpm-workspace.yaml
packages:
  - "apps/**"
  - "packages/**"
EOF

cat <<EOF > turbo.json
{
  "\$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**"] },
    "dev": { "cache": false, "persistent": true },
    "preview": { "cache": false, "persistent": true }
  }
}
EOF

mkdir -p apps/mfe-apps/{mfe1,mfe2}/src apps/shell/src packages/ui/src

# 2. Shared UI (@repo/ui)
cat <<EOF > packages/ui/package.json
{
  "name": "@repo/ui",
  "private": true,
  "main": "./src/index.tsx",
  "types": "./src/index.tsx",
  "peerDependencies": { "react": "^18.2.0" }
}
EOF

cat <<EOF > packages/ui/src/index.tsx
import React from 'react';
export const SharedButton = ({ text }: { text: string }) => (
  <button style={{ padding: '10px 20px', background: '#0070f3', color: 'white', border: 'none', borderRadius: 6, cursor: 'pointer' }}>
    {text}
  </button>
)
EOF

# 3. MFE Generator
create_mfe () {
  NAME=$1
  PORT=$2
cat <<EOF > apps/mfe-apps/$NAME/package.json
{
  "name": "$NAME",
  "private": true,
  "scripts": { "dev": "vite --port $PORT", "build": "vite build", "preview": "vite preview --port $PORT" },
  "dependencies": { "react": "^18.2.0", "react-dom": "^18.2.0", "@repo/ui": "workspace:*" },
  "devDependencies": { "vite": "latest", "typescript": "^5", "@vitejs/plugin-react": "latest", "@originjs/vite-plugin-federation": "latest" }
}
EOF

cat <<EOF > apps/mfe-apps/$NAME/vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  base: '/$NAME/',
  plugins: [
    react(),
    federation({
      name: '$NAME',
      filename: 'remoteEntry.js',
      exposes: { './App': './src/App.tsx' },
      shared: ['react', 'react-dom']
    })
  ],
  build: { target: 'esnext', minify: false, cssCodeSplit: false }
})
EOF

cat <<EOF > apps/mfe-apps/$NAME/src/App.tsx
import React from 'react';
export default () => <div style={{padding: '20px', border: '2px solid red', borderRadius: '8px'}}><h2>Micro-frontend: $NAME</h2><p>This is a remote component.</p></div>
EOF
echo "/// <reference types=\"vite/client\" />" > apps/mfe-apps/$NAME/src/vite-env.d.ts
}

create_mfe mfe1 5001
create_mfe mfe2 5002

# 4. Shell App & Environment Config
cat <<EOF > apps/shell/package.json
{
  "name": "shell",
  "private": true,
  "scripts": { "dev": "vite", "build": "vite build", "preview": "vite preview --port 5000" },
  "dependencies": { "react": "^18.2.0", "react-dom": "^18.2.0", "react-router-dom": "^6", "@repo/ui": "workspace:*" },
  "devDependencies": { "vite": "latest", "typescript": "^5", "@vitejs/plugin-react": "latest", "@originjs/vite-plugin-federation": "latest" }
}
EOF

# Local Dev Env
cat <<EOF > apps/shell/.env
VITE_MFE1_URL=http://localhost:5001/mfe1
VITE_MFE2_URL=http://localhost:5002/mfe2
EOF

# Production/Vercel Env (Relative paths for same-domain)
cat <<EOF > apps/shell/.env.production
VITE_MFE1_URL=/mfe1
VITE_MFE2_URL=/mfe2
EOF

cat <<EOF > apps/shell/vite.config.ts
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  return {
    plugins: [
      react(),
      federation({
        name: 'shell',
        remotes: {
          mfe1: \`\${env.VITE_MFE1_URL}/assets/remoteEntry.js\`,
          mfe2: \`\${env.VITE_MFE2_URL}/assets/remoteEntry.js\`
        },
        shared: ['react', 'react-dom']
      })
    ]
  }
})
EOF

cat <<EOF > apps/shell/src/App.tsx
import React, { Suspense, lazy } from 'react'
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'
import { SharedButton } from '@repo/ui'

// @ts-ignore
const Mfe1 = lazy(() => import('mfe1/App'))
// @ts-ignore
const Mfe2 = lazy(() => import('mfe2/App'))

export default () => (
  <BrowserRouter>
    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
      <h1>Host Shell</h1>
      <nav style={{ display: 'flex', gap: 15, marginBottom: '30px', background: '#f4f4f4', padding: '15px', borderRadius: '8px' }}>
        <Link to="/" style={{ textDecoration: 'none' }}><SharedButton text="Home" /></Link>
        <Link to="/mfe1" style={{ textDecoration: 'none' }}><SharedButton text="MFE 1" /></Link>
        <Link to="/mfe2" style={{ textDecoration: 'none' }}><SharedButton text="MFE 2" /></Link>
      </nav>
      <div style={{ border: '2px solid #0070f3', padding: '20px', borderRadius: '10px' }}>
        <Routes>
          <Route path="/" element={<div><h2>Welcome to the Shell</h2><p>Select an MFE above to load it at runtime.</p></div>} />
          <Route path="/mfe1" element={<Suspense fallback="Loading MFE1..."><Mfe1 /></Suspense>} />
          <Route path="/mfe2" element={<Suspense fallback="Loading MFE2..."><Mfe2 /></Suspense>} />
        </Routes>
      </div>
    </div>
  </BrowserRouter>
)
EOF

echo "/// <reference types=\"vite/client\" />\ndeclare module 'mfe1/App';\ndeclare module 'mfe2/App';" > apps/shell/src/vite-env.d.ts

# 5. Hosting & Deployment Files
cat <<EOF > vercel.json
{
  "rewrites": [
    { "source": "/mfe1/:path*", "destination": "/mfe1/index.html" },
    { "source": "/mfe2/:path*", "destination": "/mfe2/index.html" },
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
EOF

cat <<EOF > nginx.conf
server {
  listen 80;
  location / { root /usr/share/nginx/html; try_files \$uri /index.html; }
  location /mfe1/ { root /usr/share/nginx/html; try_files \$uri /mfe1/index.html; }
  location /mfe2/ { root /usr/share/nginx/html; try_files \$uri /mfe2/index.html; }
}
EOF

cat <<EOF > Dockerfile
FROM node:20-alpine AS builder
RUN npm install -g pnpm
WORKDIR /app
COPY . .
RUN pnpm install --frozen-lockfile
RUN pnpm build

FROM nginx:alpine
COPY --from=builder /app/apps/shell/dist /usr/share/nginx/html
COPY --from=builder /app/apps/mfe-apps/mfe1/dist /usr/share/nginx/html/mfe1
COPY --from=builder /app/apps/mfe-apps/mfe2/dist /usr/share/nginx/html/mfe2
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
EOF

# 6. Documentation & Instructions
cat <<EOF > README.md
# MFE Platform Monorepo



## ðŸ“‹ Steps to Build & Run
1. **Install Dependencies:**
   \`\`\`bash
   pnpm install
   \`\`\`
2. **Build All Apps:**
   Federation requires the remoteEntry.js files to exist.
   \`\`\`bash
   pnpm build
   \`\`\`
3. **Run Dev Servers:**
   \`\`\`bash
   pnpm dev
   \`\`\`
   - Shell: http://localhost:5173
   - MFE1: http://localhost:5001/mfe1
   - MFE2: http://localhost:5002/mfe2

## ðŸš€ Deployment (AWS / Docker)
1. **Build Docker Image:**
   \`\`\`bash
   docker build -t mfe-platform-image .
   \`\`\`
2. **Push to JFrog:**
   Use your Bamboo pipeline to tag and push to your registry.
3. **Deploy with Helm:**
   Point your ingress paths (\`/mfe1\`, \`/mfe2\`) to this service.
EOF

# 7. Finishing Root Configs
cat <<EOF > tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext", "module": "ESNext", "jsx": "react-jsx",
    "moduleResolution": "Node", "strict": true, "skipLibCheck": true,
    "baseUrl": ".", "paths": { "@repo/ui": ["packages/ui/src/index.tsx"] }
  }
}
EOF

cat <<EOF > apps/shell/index.html
<!DOCTYPE html><html><body><div id="root"></div><script type="module" src="/src/main.tsx"></script></body></html>
EOF
echo "import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; ReactDOM.createRoot(document.getElementById('root')!).render(<App />);" > apps/shell/src/main.tsx

pnpm install
echo "âœ… SCAFFOLDING COMPLETE."
echo "ðŸ‘‰ Check README.md for execution steps."

ðŸ“ˆ Next Logical Steps
Now that your local and Vercel environments are rock solid, would you like me to generate the Bamboo Specs YAML to automate the build/push to JFrog, or the Helm Chart values to deploy this container to AWS?
